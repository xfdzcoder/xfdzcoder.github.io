---
url: /-1
title: '草稿'
date: 2024-07-27T20:03:17+08:00
lastmod: 2024-07-30T20:03:17+08:00
draft: true
summary: ""
categories: [面试]
tags: []
---

## Java基础

### 1. 常用的集合

<details>
    <summary>提示</summary>
    <pre>线程安全的集合和非线程安全的集合、哈希表</pre>
</details>

- 线程不安全的集合
  - `ArrayList`、`LinkedList`、`HashSet`、`TreeSet`、`HashMap`、`TreeMap`、`LinkedHashMap`
- 线程安全的集合
  - `CopyOnWriteArrayList`、`ConcurrentHashMap`、`CopyOnWriteArraySet`

线程安全的集合的实现原理
- 写时复制，所以叫 `CopyOnWrite`
- `ConcurrentHashMap` 分段锁（1.7）和CAS+synchronized（1.8）

### 2. `ArrayList` 和 `LinkedList` 的优缺点

ArrayList 是数组实现

- 增删操作会有额外的复制成本，但是随机访问速度很快

LinkedList 是双向链表实现

- 增删操作只需要操作指针节点，但是随机访问需要额外的遍历成本

### 3. `ArrayList` 的扩容倍数是？为什么？

<details>
    <summary>提示</summary>
    <pre>如果扩容倍数过大或过小会有什么问题</pre>
</details>
1.5倍。

这是综合考虑了时间空间复杂度，因为如果设置的过大，那么就会造成空间的浪费，设置的过小会导致频繁的扩容，导致时间复杂度的增加。

### 4. `HashMap` 的扩容基数为什么是 0.75

根据源码注释来看，这是经过数学统计学验证后得到的一个最合适的值，在这个时候他的整体性能最优。

>ChatGPT 的回答：
>
>在您提供的这段注释中，涉及到了 **HashMap** 中 **TreeNodes** 的使用以及桶（bin）中节点数量的概率分布。具体来说，这些数据描述了在默认负载因子（**load factor**）为0.75的情况下，假设哈希码是随机分布的，HashMap 中每个桶中节点数量（即链表长度）遵循 **泊松分布（Poisson distribution）**，其参数 λ（平均发生率）约为0.5。下面详细解释这些数据的含义：
>
>### 1. 泊松分布简介
>泊松分布是一种离散概率分布，用于描述在固定时间或空间范围内，某事件发生次数的概率。其概率质量函数（PMF）为：
>
>\[ P(k) = \frac{e^{-\lambda} \cdot \lambda^k}{k!} \]
>
>其中：
>- \( \lambda \) 是单位时间或空间内事件的平均发生次数。
>- \( k \) 是事件发生的具体次数。
>- \( e \) 是自然对数的底数，约等于2.71828。
>
>在这个上下文中，**λ = 0.5** 表示每个桶中平均有0.5个节点。
>
>### 2. 数据解释
>这些数据列出了在 λ = 0.5 的泊松分布下，每个桶中有 **k** 个节点的概率：
>
>- **0个节点 (k = 0)**: 约 **60.653066%**
>  - 大约60.65%的桶是空的，没有任何节点。
>  
>- **1个节点 (k = 1)**: 约 **30.326533%**
>  - 大约30.33%的桶中有一个节点。
>  
>- **2个节点 (k = 2)**: 约 **7.581633%**
>  - 大约7.58%的桶中有两个节点。
>  
>- **3个节点 (k = 3)**: 约 **1.263606%**
>  - 大约1.26%的桶中有三个节点。
>  
>- **4个节点 (k = 4)**: 约 **0.157952%**
>  - 大约0.16%的桶中有四个节点。
>  
>- **5个节点 (k = 5)**: 约 **0.015795%**
>  - 大约0.016%的桶中有五个节点。
>  
>- **6个节点 (k = 6)**: 约 **0.001316%**
>  - 大约0.0013%的桶中有六个节点。
>  
>- **7个节点 (k = 7)**: 约 **0.0000094%**
>  - 大约0.0000094%的桶中有七个节点。
>  
>- **8个节点 (k = 8)**: 约 **0.0000006%**
>  - 大约0.0000006%的桶中有八个节点。
>  
>- **更多节点 (k > 8)**: 概率 **小于百万分之一**
>  - 桶中超过八个节点的概率极低，几乎可以忽略不计。
>
>### 3. 这些数据的意义
>
>#### **性能优化**
>- **大多数桶为空或只有少量节点**：如上所示，大约90%以上的桶中有0到2个节点。这意味着大多数查找、插入和删除操作可以在常数时间内完成，保持HashMap的高性能。
>  
>- **极少数桶需要转换为树结构**：当某个桶中的节点数量超过一定阈值（如TREEIFY_THRESHOLD），HashMap会将链表转换为红黑树（**TreeNodes**），以提高性能。在泊松分布下，超过2个节点的桶比例非常低（约9%），而更多节点的桶几乎不可能存在。这减少了树化操作的频率，节省了内存和计算资源。
>
>#### **内存与时间的平衡**
>- **内存使用**：较低的负载因子（0.75）确保了较低的桶填充度，减少了哈希冲突的概率，从而降低了链表或树结构的使用频率。这在内存和时间效率之间取得了良好的平衡。
>  
>- **扩容策略**：通过合理的负载因子和桶大小分布，HashMap减少了扩容操作的频率。频繁的扩容会带来性能开销，而合理的负载因子可以延迟扩容，优化整体性能。
>
>#### **鲁棒性**
>- **应对哈希冲突**：即使在哈希函数表现不佳的情况下（例如大量不同键具有相同的哈希码），HashMap也能通过树化机制保证最坏情况下的操作时间复杂度为O(log n)，而不是退化到链表的O(n)。
>
>### 4. 总结
>这些概率数据展示了在默认负载因子0.75和泊松分布参数λ=0.5下，HashMap中每个桶中节点数量的预期分布情况。这些数据支持了HashMap在设计上的诸多决策，如选择合适的负载因子、链表与树结构的转换策略，以及扩容机制的实现，最终确保了在大多数情况下HashMap都能高效地执行其基本操作。

### 5. 反射的好处？

<details>
    <summary>提示</summary>
    <pre>缺点：可以从Java9的模块化入手</pre>
</details>
好处：

- 提供了动态性和灵活性。因为反射允许我们在运行时动态的加载类、创建对象、调用方法、访问字段等等。
- 这也催生了一系列的优秀框架，例如我们经常用的 `Spring` 等

缺点：

- 大家常说的反射性能问题，我觉得并不是问题，反射的慢实际上在Web应用中几乎可以忽略不计，因为网络和磁盘的IO远大于反射所耽误的时间。
- 我认为反射主要的缺点在于它打破了面向对象三大特性中的封装，我们使用封装就是为了让外部无法访问，可是反射可以轻而易举的打破这个访问限制。为了解决这个问题，`Java9` 的时候推出了模块化系统，我们可以通过模块化系统提供的 `open`、`opens`、`provides` 等等关键字来暴露模块，让外部可以通过反射访问，也可以选择不暴露模块，这样外部在通过反射试图破坏封装性的时候将会收到一个 `InaccessibleObjectException`

### 6. 平时有用过反射吗？做了些什么？

有用过，学习JDBC的阶段使用过反射去动态加载驱动类。

### 7. 面向对象三大特性

封装继承多态。

封装：封装是指把数据和行为绑定到一起形成一个独立的对象，对外隐藏实现细节，只提供声明来供外部使用。

继承：继承是指一个类从他的父类继承属性和方法，这样子类就可以在父类的基础上进行扩展，或者是重写父类的方法。

多态：多态是指同一个行为在不同实现中的不同表现形式，比如最常用的例子就是有一个行为是 发出声音，这个行为在猫身上是喵，在狗身上是汪，这就是不同的表现形式，发出声音这个行为具体是什么表现形式由他的具体实现来决定，这就是多态。

### 8. 多态的几种实现方式？

在Java中，多态主要有两种实现方式：**编译时多态（静态多态）和 运行时多态（动态多态）**。这两种多态性是通过不同的机制实现的，各自有不同的应用场景。

编译时多态是指在编译阶段就可以确定要调用的方法，这种多态主要是通过方法的重载去实现的。

运行时多态是指在运行阶段才能确定要调用的方法，这种多态主要通过方法重写和接口实现来实现的，

### 9. `try-catch-finally` 中都进行`return` ，最终会返回哪一个值？`catch` 中的代码块会执行吗？

返回 `finally` 中的 `return` ，`catch` 代码块依旧会执行，只是它返回的值会被 `finally` 中返回的值覆盖掉。

### 10. 常用的垃圾回收器

<details>
    <summary>扩展</summary>
    <pre>CMS 垃圾回收器，一般公司里都会更换为 CMS</pre>
</details>
[JVM垃圾回收详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#前言)

### 11. JVM 调优参数用过哪些？

[最重要的JVM参数总结 | JavaGuide](https://javaguide.cn/java/jvm/jvm-parameters-intro.html)

### 12. `synchronized` 的底层是调用的操作系统的哪个操作？

<details>
    <summary>提示</summary>
    <pre>mutex 锁，重量级锁</pre>
</details>
[Java锁与线程的那些事 (youzan.com)](https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/)

### 13. 线程池常用的几个参数

[Java并发常见面试题总结（下） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#线程池常见参数有哪些-如何解释)

### 14. 为什么要先填满阻塞队列然后再创建线程？

阻塞队列的存在就是充当一个缓存，如果核心线程满了之后，再来任务就直接创建非核心线程去处理的话，那么可能会出现在某一个时间请求量激增，创建了大量的非核心线程，然后这些线程执行完了过一段时间又会被销毁掉，这是比较消耗资源的。而一开始就将任务放进队列去排队，这样就可以达到一个削峰的作用，即使某一个时间请求了激增，也不会创建过多的线程导致系统压力猛增，直接放进队列可以让峰值流量被均摊下来，以减轻系统压力。

### 15. 默认拒绝策略？

[Java并发常见面试题总结（下） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#线程池的拒绝策略有哪些)

默认是 `ThreadPoolExecutor.AbortPolicy`

## Spring

### 1. 谈谈你对 AOP、IoC 的理解

AOP是面向切面编程，切面就是所有的调用路径上都需要经过的地方，我们可以在切面中进行一些统一的操作，比如日志打印、异常处理等等。Spring中的AOP主要是通过动态代理去实现的，使用时需要使用 @Aspect 注解，然后在里面定义切点和通知，切点就是需要被增强的方法，通知就是我们要做的事情，它分为前置、后置、返回、环绕、异常通知。

IoC是控制反转，是一种设计原则。他把对象的创建和依赖关系的管理交给外部容器，最开始我们是通过直接 new 对象，然后处理这个对象的依赖关系，这个时候控制权在我们，我们需要维护这个对象生命周期、如创建、初始化、销毁等等。而 IoC 这种设计原则就是把控制权交出去，让外部容器来负责这个对象的生命周期，如创建、初始化、销毁等等。这样有下面几个好处：

- 可以解耦合，直接 new 的方式将两个对象强耦合在一起，而通过 IoC 的方式可以让我们不再关注对象的依赖关系、生命周期。就是A只需要知道A依赖B，但是不用关心B依赖谁，如果自己 new 的话，A 就需要管理 B 的依赖关系，这样 A 和 其他对象也会产生依赖，耦合度过高。
- 另外也起到了一个缓存的作用，比如Spring中的 IoC，可以把对象的生命周期延长到和应用程序一样长，而不需要每次接收到新请求就重新创建对象，可以实现对象的复用。

### 2. AOP 的默认实现方式？两种方式的区别和应用场景？

 [浅析Spring中AOP的实现原理——动态代理 - 特务依昂 - 博客园 (cnblogs.com)](https://www.cnblogs.com/tuyang1129/p/12878549.html)

### 3. IoC 的优点

### 4. IoC 为什么要有三层缓存？

### 5. 如果 Bean 不是单例的，还能解决循环依赖吗？

## SpringMVC

### 1. 讲讲 `DispatcherServlet` 的处理流程

### 2. 讲讲 `HandlerMapping` 和 `HandlerAdater`  

## MyBatis

### 1. `Mybatis` 中的 `#` 和 `$` 有什么区别？

## SpringBoot

### 1. 怎么写一个 `starter` ？如何让用户自定义一些参数？

<details>
    <summary>扩展</summary>
    <pre>springboot 3.x 中对配置方式进行了更新，弃用了原来的方式</pre>
</details>

## SpringCloud

### 1. 大型项目中依赖的版本如何管理

<details>
    <summary>扩展</summary>
    <pre>maven 新版本中有一个默认属性：revision，用于统一管理项目本身的版本</pre>
</details>

## MySQL

### 1. 用过索引吗？用索引的时候你一般会考虑哪些问题？

### 2. 有遇到过索引失效的场景吗？

### 3. 有过 SQL 优化经验吗？

### 4. 你写 SQL 一般会注意什么？

### 5. `>=` 和 `>` 在索引方面有什么区别吗？

### 6. 了解过索引的结构吗？

## Redis

### 1. 了解 Redis 的过期策略吗？

### 2. 讲讲内存淘汰的几种策略？

## MQ

### 1. 消息队列如何确保消息的可靠性

## 简历

### 1. 问题点：从0到1搭建GitHub+Jenkins

#### 1.1 用的 Linux 吗？你的 Linux 可以直接访问 GitHub 吗？

#### 1.2 运维是要保证稳定性的，GitHub 访问失败怎么解决？

（51:15）

<details>
    <summary>提示</summary>
    <pre>GitLab 自建服务器</pre>
</details>

### 2. 问题点：为活动、订单服务开发ID生成服务，通过 Redisson 分布式锁确保唯一性

### 2.1 活动服务也需要唯一ID吗？并发量很高吗？

### 2.2 Redisson 可是重量级锁，订单这种高并发的模块需要挨个排队等待吗？

<details>
    <summary>提示</summary>
    <pre>通过雪花算法</pre>
</details>

### 3. 问题点：你在学习和开发过程中遇见的最大的问题是什么？你是怎么解决的？

### 4. 



















【课题描述】 随着人们生活水平的提高，棋牌娱乐逐渐成为了大众喜爱的休闲活动之一。为了便于棋牌室的管理，提高服务效率，设计和实现一套棋牌室管理系统显得尤为重要。传统的棋牌室管理主要依赖于人工记录和管理，不仅效率低下，还容易出现信息错漏，影响客户体验。为了解决这些问题，本系统旨在通过互联网技术，将棋牌室的预订、管理、会员服务等功能集成到一个平台上，使得客户能够方便地在线预订棋牌室，查看消费记录，会员可以享受更多的优惠和个性化服务。系统将极大地提升棋牌室的管理效率，降低运营成本，并且通过数字化手段为客户提供更加优质的服务。  【技术架构】  该棋牌室管理系统是一个前后端分离的项目，前端使用Vue.js框架结合Element UI组件库进行开发，能够快速构建响应式界面，提升用户体验。后端基于Spring Boot框架，结合MyBatis进行数据持久化操作，采用MySQL数据库进行数据存储，保障系统数据的安全性和可靠性。Spring Boot提供了简洁的配置和快速的开发能力，能够帮助开发者迅速搭建项目框架并专注于业务逻辑的实现。同时，系统采用了软件工程思想，经过系统的需求分析、设计、实现和测试，确保系统的稳定性和可维护性。通过这些技术的应用，棋牌室管理系统不仅能够高效完成日常管理任务，还为未来的功能扩展和维护打下了坚实的基础。  【功能模块】 1. 棋牌室预订模块 1.1 在线预订 	用户可以通过平台在线查看棋牌室的房间列表，并根据需求选择房间进行预订。系统允许用户选择具体的日期和时间段，显示可用房间的实时状态和价格。用户可以直接在平台上完成预订并收到确认信息。在线预订功能极大地方便了用户，减少了人工沟通的时间成本，提高了预订效率。 1.2 预订管理 	管理员可以通过后台系统管理所有的房间预订信息，查看所有预订单的详情，包括用户信息、预订时间和房间号等。系统还支持管理员对预订进行修改或取消，并提供预订冲突提醒功能。通过预订管理，管理员能够有效地分配资源，减少预订冲突，确保棋牌室的高效运作。 1.3 历史记录 	用户可以在个人中心查看自己的预订历史记录，详细显示每次预订的时间、房间、费用等信息。历史记录功能帮助用户追溯自己的消费行为，并为未来的预订提供参考。同时，这些记录也是用户维权的重要依据。  2. 会员管理模块 2.1 会员注册 	用户可以通过平台进行会员注册，填写个人信息并设置密码，成功注册后可享受平台提供的各类会员服务。注册流程简单便捷，并支持社交账号快速注册。通过会员注册，平台能够建立起用户档案，为后续的个性化服务打下基础。 2.2 会员信息 	注册成为会员后，用户可以在个人中心查看并更新自己的信息，包括姓名、联系方式、密码等。平台还会根据用户的消费行为和活跃度分配会员等级，并在会员信息中显示当前的等级和积分情况。会员信息的管理帮助用户掌握自己的权益，并促进平台对用户的个性化服务。 2.3 会员优惠 	平台为会员提供了多种优惠措施，如积分兑换、优惠券发放等，会员可以在个人中心查看并使用这些优惠。积分兑换可以用于房间预订折扣、比赛报名费减免等，提升了用户的参与感和忠诚度。会员优惠功能不仅提高了用户的满意度，还增强了客户黏性，促进了用户的活跃度。  3. 订单管理模块 3.1 消费记录 	用户可以在个人中心查看自己的所有消费记录，内容包括预订的棋牌室、消费金额、日期和支付方式等。消费记录的透明化管理帮助用户更好地了解自己的消费情况，并为后续消费提供参考。管理员也可以通过后台查看所有用户的消费记录，以分析用户行为和调整运营策略。 3.2 支付管理 	系统支持多种支付方式，用户可以在平台上选择在线支付、到店支付等。在线支付支持多种支付通道，如支付宝、微信支付、信用卡等，确保用户支付的便利性和安全性。支付管理功能还包括支付状态跟踪和异常支付处理，确保交易的顺畅和安全。 3.3 订单统计 	管理员可以通过后台查看每日、每周、每月的订单统计数据，系统自动生成图表和报告，帮助管理者了解平台的运营情况。这些统计数据包括订单数量、订单金额、用户数量等多个维度，为经营决策提供了可靠的数据支持。通过订单统计功能，管理员能够及时发现问题，调整经营策略，提高平台的盈利能力。  4. 比赛组织模块 4.1 比赛创建与管理 	管理员可以通过平台创建各类棋牌比赛，设置比赛规则、报名条件、参赛人数和奖品等。比赛可以是单次赛事，也可以是联赛形式，系统支持对比赛过程的全程管理，包括赛程安排、结果统计等。比赛创建功能不仅丰富了平台的娱乐内容，还能吸引更多用户参与，提高用户活跃度。 4.2 比赛结果统计 	比赛结束后，系统会自动统计比赛结果，并生成详细的比赛报告。参赛用户可以在个人中心查看自己的比赛成绩和获奖情况，管理员则可以在后台查看比赛的全局数据，包括参赛人数、胜负比例、奖品发放等。通过比赛结果统计，平台能够为用户提供数据支持，并为后续的比赛优化提供参考。 4.3 报名管理 	用户可以通过平台报名参加各类比赛，系统会根据报名情况动态调整参赛名额。报名管理功能支持自动生成报名表，并提供报名确认通知。管理员可以查看报名情况，并根据需要调整报名条件或开放新的名额，确保比赛的顺利进行。  5. 积分管理模块 5.1 积分规则设置 	管理员可以设定用户积分获取的规则，积分可以通过多种方式获得，如房间预订、比赛参与、平台活动等。积分的获取规则透明且灵活，能够激励用户更多地参与平台活动。管理员还可以根据平台运营情况随时调整积分规则，确保积分体系的公平性和激励性。 5.2 积分查询与兑换 	用户可以在个人中心实时查看自己的积分余额和历史积分获取记录。平台提供多种积分兑换选项，用户可以使用积分兑换房间预订折扣、比赛报名费减免等。这一功能提升了用户的参与感和粘性，鼓励用户长期使用平台服务。 5.3 积分商城 	积分商城是平台提供给用户的一项福利，用户可以使用积分在商城中兑换商品、优惠券、体验券等。积分商城商品种类丰富，涵盖了用户的日常需求和娱乐需求。通过积分商城，平台能够进一步提升用户的活跃度和忠诚度，同时也为平台运营带来了额外的收益。  6. 后台管理模块 6.1 系统设置 	管理员可以通过后台管理系统进行各种基础设置，如用户权限配置、操作日志查看、系统通知设置等。系统设置功能确保了平台的灵活性和可控性，管理员可以根据需要随时调整平台的配置参数，确保系统的稳定运行。 6.2 数据备份与恢复 	为了保障系统数据的安全性，平台提供了数据备份和恢复功能。管理员可以手动或自动定期备份系统数据，并在数据丢失或系统崩溃时快速恢复。这一功能极大地提高了系统的可靠性，降低了运营风险。 6.3 报表生成 	平台支持生成各类经营报表，包括财务报表、订单报表、用户报表等。管理员可以根据这些报表分析平台的运营状况，制定合理的经营策略。报表生成功能不仅提高了管理效率，还为决策提供了科学的数据支持。